// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2797.KnightsFRC2018v2;

import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SPI;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static SpeedController drivetrainfrontLeft;
    public static SpeedController drivetrainrearLeft;
    public static SpeedControllerGroup drivetrainleft;
    public static SpeedController drivetrainfrontRight;
    public static SpeedController drivetrainrearRight;
    public static SpeedControllerGroup drivetrainright;
    public static DifferentialDrive drivetrainDrive;
    public static Encoder drivetrainleftEnc;
    public static Encoder drivetrainrightEnc;
    public static DigitalInput elevatortopLimit;
    public static DigitalInput elevatorbottomLimit;
    public static Encoder elevatorelevatorEnc;
    public static SpeedController elevatorpto1;
    public static SpeedController elevatorpto2;
    public static SpeedControllerGroup elevatorpto;
    public static Solenoid elevatorPtoLock;
    public static Solenoid elevatorPtoShifter;
    public static Compressor clawcompressor;
    public static Encoder clawintakeEnc;
    public static SpeedController clawintake;
    public static PIDController clawintakePID;
    public static Solenoid clawOpen;
    public static Solenoid clawLift;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
//    public static Solenoid clawLift;
//    public static Solenoid ptoShifter;
//    public static Solenoid ptoLock;
    
    public static AHRS navX;
    

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        drivetrainfrontLeft = new Spark(0);
        LiveWindow.addActuator("Drivetrain", "frontLeft", (Spark) drivetrainfrontLeft);
        drivetrainfrontLeft.setInverted(false);
        drivetrainrearLeft = new Spark(1);
        LiveWindow.addActuator("Drivetrain", "rearLeft", (Spark) drivetrainrearLeft);
        drivetrainrearLeft.setInverted(false);
        drivetrainleft = new SpeedControllerGroup(drivetrainfrontLeft, drivetrainrearLeft  );
        LiveWindow.addActuator("Drivetrain", "left", drivetrainleft);
        
        drivetrainfrontRight = new Spark(2);
        LiveWindow.addActuator("Drivetrain", "frontRight", (Spark) drivetrainfrontRight);
        drivetrainfrontRight.setInverted(false);
        drivetrainrearRight = new Spark(3);
        LiveWindow.addActuator("Drivetrain", "rearRight", (Spark) drivetrainrearRight);
        drivetrainrearRight.setInverted(false);
        drivetrainright = new SpeedControllerGroup(drivetrainfrontRight, drivetrainrearRight  );
        LiveWindow.addActuator("Drivetrain", "right", drivetrainright);
        
        drivetrainDrive = new DifferentialDrive(drivetrainleft, drivetrainright);
        LiveWindow.addActuator("Drivetrain", "Drive", drivetrainDrive);
        drivetrainDrive.setSafetyEnabled(true);
        drivetrainDrive.setExpiration(0.1);
        drivetrainDrive.setMaxOutput(1.0);

        drivetrainleftEnc = new Encoder(0, 1, false, EncodingType.k2X);
        LiveWindow.addSensor("Drivetrain", "leftEnc", drivetrainleftEnc);
        drivetrainleftEnc.setDistancePerPulse(1.0);
        drivetrainleftEnc.setPIDSourceType(PIDSourceType.kDisplacement);
        drivetrainrightEnc = new Encoder(2, 3, false, EncodingType.k2X);
        LiveWindow.addSensor("Drivetrain", "rightEnc", drivetrainrightEnc);
        drivetrainrightEnc.setDistancePerPulse(1.0);
        drivetrainrightEnc.setPIDSourceType(PIDSourceType.kDisplacement);
        elevatortopLimit = new DigitalInput(4);
        LiveWindow.addSensor("Elevator", "topLimit", elevatortopLimit);
        
        elevatorbottomLimit = new DigitalInput(5);
        LiveWindow.addSensor("Elevator", "bottomLimit", elevatorbottomLimit);
        
        elevatorelevatorEnc = new Encoder(6, 7, false, EncodingType.k2X);
        LiveWindow.addSensor("Elevator", "elevatorEnc", elevatorelevatorEnc);
        elevatorelevatorEnc.setDistancePerPulse(1.0);
        elevatorelevatorEnc.setPIDSourceType(PIDSourceType.kRate);
        elevatorpto1 = new Spark(4);
        LiveWindow.addActuator("Elevator", "pto1", (Spark) elevatorpto1);
        elevatorpto1.setInverted(false);
        elevatorpto2 = new Spark(5);
        LiveWindow.addActuator("Elevator", "pto2", (Spark) elevatorpto2);
        elevatorpto2.setInverted(false);
        elevatorpto = new SpeedControllerGroup(elevatorpto1, elevatorpto2  );
        LiveWindow.addActuator("Elevator", "pto", elevatorpto);
        
        elevatorPtoLock = new Solenoid(0, 1);
        LiveWindow.addActuator("Elevator", "PtoLock", elevatorPtoLock);
        
        elevatorPtoShifter = new Solenoid(0, 0);
        LiveWindow.addActuator("Elevator", "PtoShifter", elevatorPtoShifter);
        
        clawcompressor = new Compressor(0);
        LiveWindow.addActuator("Claw", "compressor", clawcompressor);
        
        clawintakeEnc = new Encoder(8, 9, false, EncodingType.k2X);
        LiveWindow.addSensor("Claw", "intakeEnc", clawintakeEnc);
        clawintakeEnc.setDistancePerPulse(1.0);
        clawintakeEnc.setPIDSourceType(PIDSourceType.kRate);
        clawintake = new Spark(6);
        LiveWindow.addActuator("Claw", "intake", (Spark) clawintake);
        clawintake.setInverted(false);
        clawintakePID = new PIDController(1.0, 0.0, 0.0, 0.0, clawintakeEnc, clawintake, 0.02);
        LiveWindow.addActuator("Claw", "intakePID", clawintakePID);
        clawintakePID.setContinuous(false);
        clawintakePID.setAbsoluteTolerance(0.2);

        clawintakePID.setOutputRange(-1.0, 1.0);
        SmartDashboard.putData("Claw intakePID", clawintakePID);
        clawOpen = new Solenoid(0, 2);
        LiveWindow.addActuator("Claw", "Open", clawOpen);
        
        clawLift = new Solenoid(0, 3);
        LiveWindow.addActuator("Claw", "Lift", clawLift);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
//        clawLift = new Solenoid(0, 3);
//        LiveWindow.addActuator("Claw", "Arm up/down", clawLift);
//        
//        ptoShifter = new Solenoid(0, 0);
//        LiveWindow.addActuator("Elevator", "ptoShifter", ptoShifter);
//        
//        ptoLock = new Solenoid(0, 1);
//        LiveWindow.addActuator("Elevator", "ptoLock", ptoLock);
        
        navX = new AHRS(SPI.Port.kMXP);
    }
}
