// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2797.KnightsFRC2018v2.subsystems;

import org.usfirst.frc2797.KnightsFRC2018v2.RobotMap;
import org.usfirst.frc2797.KnightsFRC2018v2.commands.TeleopDrive;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Drivetrain extends Subsystem implements PIDOutput {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	private final double WheelCircumference = .5 * Math.PI;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final SpeedController frontLeft = RobotMap.drivetrainfrontLeft;
	private final SpeedController rearLeft = RobotMap.drivetrainrearLeft;
	private final SpeedControllerGroup left = RobotMap.drivetrainleft;
	private final SpeedController frontRight = RobotMap.drivetrainfrontRight;
	private final SpeedController rearRight = RobotMap.drivetrainrearRight;
	private final SpeedControllerGroup right = RobotMap.drivetrainright;
	private final DifferentialDrive drive = RobotMap.drivetrainDrive;
	private final Encoder leftEnc = RobotMap.drivetrainleftEnc;
	private final Encoder rightEnc = RobotMap.drivetrainrightEnc;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private final PIDController leftPID;
	private final PIDController rightPID;
	private final AHRS navX = RobotMap.navX;
	private final PIDController gyroPID;

	double rotateToAngleRate;
	double driveDistRate;

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new TeleopDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	@Override
	public void periodic() {
		// Put code here to be run every loop

	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public Drivetrain() {
		leftPID = new PIDController(0.0075, 0.01, 0.0, 0.0, leftEnc, this);
		leftPID.setAbsoluteTolerance(1000.0);
		leftPID.setInputRange(Double.MIN_VALUE, Double.MAX_VALUE);
		leftPID.setOutputRange(-1.0, 1.0);
		leftPID.setContinuous(false);
		// leftPID.enable();
		LiveWindow.addActuator("Drivetrain", "leftPID", leftPID);

		rightPID = new PIDController(0.0075, 0.01, 0.0, 0.0, rightEnc, this);
		rightPID.setAbsoluteTolerance(1000.0);
		rightPID.setInputRange(Double.MIN_VALUE, Double.MAX_VALUE);
		rightPID.setOutputRange(-1.0, 1.0);
		rightPID.setContinuous(false);
		// rightPID.enable();
		LiveWindow.addActuator("Drivetrain", "rightPID", rightPID);

		gyroPID = new PIDController(0.03, 0.01, 0.0, navX, this);
		gyroPID.setAbsoluteTolerance(1.0);
		gyroPID.setInputRange(-360.0, 360.0);
		gyroPID.setOutputRange(-1.0, 1.0);
		gyroPID.setContinuous(true);
		gyroPID.disable();
		LiveWindow.addActuator("NavX", "gyroPID", gyroPID);
		//SmartDashboard.putData("NavX PID", gyroPID);

	}

	/**
	 * Get the PID controller used for rotational movement.
	 * @return The gyroPID
	 */
	public PIDController getGyroPID() {
		return gyroPID;
	}
	
	/**
	 * Reset the rotation of the navX.
	 */
	public void resetNavXYaw() {
		navX.zeroYaw();
	}

	/**
	 * Reset the encoders for the wheels.
	 */
	public void resetEncoders() {
		leftEnc.reset();
		rightEnc.reset();
	}

	/**
	 * Reset the PID controllers for the wheels.
	 */
	public void resetPID() {
		leftPID.setSetpoint(0.0);
		rightPID.setSetpoint(0.0);
	}

	/**
	 * Enable the PID controllers for the wheels.
	 */
	public void enablePID() {
		rightPID.enable();
		leftPID.enable();
	}

	/**
	 * Disable the PID controllers for the wheels.
	 */
	public void disablePID() {
		rightPID.disable();
		leftPID.disable();
	}

	/**
	 * Drive the wheels using the input speeds.
	 * @param leftSpeed The speed of the left wheels.
	 * @param rightSpeed The speed of the right wheels.
	 */
	public void driveRobot(double leftSpeed, double rightSpeed) {
		drive.tankDrive(leftSpeed * -1, rightSpeed * -1);
	}

	/**
	 * Stop the wheel motors and disable the PID controllers.
	 */
	public void stop() {
		drive.tankDrive(0, 0);
		disablePID();
	}

	/**
	 * Drive a distance at a specific speed.
	 * @param distance The distance to drive in feet. (Relative to the current position)
	 * @param speed The speed at which to move.
	 */
	public void driveDistance(double distance, double speed) {

		leftPID.enable(); //Enable the left PID.
		double lSetpoint = leftPID.getSetpoint(); //Get the current set-point of the left PID.

		leftPID.setOutputRange(-speed, speed); //Set the max speed of the left PID.

		leftPID.setSetpoint(lSetpoint + (int) (distance * (360 / WheelCircumference))); //Add the distance to the current set-point.
		
		while(leftPID.isEnabled()) { //While the left PID is enabled...
			drive.tankDrive(driveDistRate, 0.98*driveDistRate); //... drive the forward.
			
			if(leftPID.onTarget()) //If the left PID has reached the set-point...
				disablePID(); //... disable the PID.
		}
	}

	public void turnToAngle(double angle, double speed) {
		gyroPID.setOutputRange(-speed, speed);

		if (rightPID.isEnabled() || leftPID.isEnabled()) {
			System.out.println("Drivetrain pids were enabled, disabling");
			leftPID.disable();
			rightPID.disable();
		}

		System.out.println("Resetting navX yaw");
		navX.zeroYaw();

		if (!gyroPID.isEnabled()) {
			System.out.println("Gyro pid disabled, enabling");
			gyroPID.setSetpoint(angle);
			rotateToAngleRate = 0;
			gyroPID.enable();
		}

		while (gyroPID.isEnabled()) {
			drive.tankDrive(rotateToAngleRate, -rotateToAngleRate);

			if (gyroPID.onTarget()) {
				gyroPID.disable();
			}
		}
	}

	/**
	 * Get either the left PID or right PID.
	 * @param isLeft If the desired PID controller is left PID.
	 * @return The PID controller for either the left or right side.
	 */
	public PIDController getPIDController(boolean isLeft) {

		if (isLeft) //If the left side is desired...
			return leftPID; //... return the left PID...
		else //... otherwise...
			return rightPID;// ...return the right PID.
	}

	public void pidWrite(double output) {
		rotateToAngleRate = output; //The rate used for the rotation method.
		driveDistRate = output; //The rate used for the drive distance method.
	}
}
